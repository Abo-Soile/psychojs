<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data/Shelf.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: data/Shelf.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module data */
/**
 * Shelf handles persistent key/value pairs, or records, which are stored in the shelf collection on the
 * server, and be accessed and manipulated in a concurrent fashion.
 *
 * @author Alain Pitiot
 * @copyright (c) 2022 Open Science Tools Ltd. (https://opensciencetools.org)
 * @license Distributed under the terms of the MIT License
 */

import {PsychObject} from "../util/PsychObject.js";
import {PsychoJS} from "../core/PsychoJS.js";
import {ExperimentHandler} from "./ExperimentHandler";
import {Scheduler} from "../util/Scheduler.js";


/**
 * &lt;p>Shelf handles persistent key/value pairs, or records, which are stored in the shelf collection on the
 * server, and be accessed and manipulated in a concurrent fashion.&lt;/p>
 *
 * &lt;p>&lt;/p>
 *
 * @name module:data.Shelf
 * @class
 * @extends PsychObject
 * @param {Object} options
 * @param {module:core.PsychoJS} options.psychoJS 	the PsychoJS instance
 * @param {boolean} [options.autoLog= false] 				whether to log
 */
export class Shelf extends PsychObject
{
	/**
	 * Maximum number of components in a key
	 * @name module:data.Shelf.#MAX_KEY_LENGTH
	 * @type {number}
	 * @note this value should mirror that on the server, i.e. the server also checks that the key is valid
	 */
	static #MAX_KEY_LENGTH = 10;

	constructor({psychoJS, autoLog = false } = {})
	{
		super(psychoJS);

		this._addAttribute('autoLog', autoLog);
		this._addAttribute('status', Shelf.Status.READY);

		// minimum period of time, in ms, before two calls to Shelf methods, i.e. throttling:
		this._throttlingPeriod_ms = 500.0;

		// timestamp of the last actual call to a Shelf method:
		this._lastCallTimestamp = 0.0;
		// timestamp of the last scheduled call to a Shelf method:
		this._lastScheduledCallTimestamp = 0.0;
	}

	/**
	 * Get the value of a record of type BOOLEAN associated with the given key.
	 *
	 * @name module:data.Shelf#getBooleanValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key					 	key as an array of key components
	 * @param {boolean} options.defaultValue		the default value returned if no record with the given key exists
	 * 	on the shelf
	 * @return {Promise&lt;boolean>}								the value associated with the key
	 * @throws {Object.&lt;string, *>} 						exception if there is a record associated with the given key
	 * 	but it is not of type BOOLEAN
	 */
	getBooleanValue({key, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.BOOLEAN, {defaultValue});
	}

	/**
	 * Set the value of a record of type BOOLEAN associated with the given key.
	 *
	 * @name module:data.Shelf#setBooleanValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 	key as an array of key components
	 * @param {boolean} options.value 		the new value
	 * @return {Promise&lt;boolean>}					the new value
	 * @throws {Object.&lt;string, *>} 			exception if value is not a boolean, or if there is no record with the given
	 * 	key, or if there is a record but it is locked or it is not of type BOOLEAN
	 */
	setBooleanValue({key, value} = {})
	{
		// check the value:
		if (typeof value !== "boolean")
		{
			throw {
				origin: "Shelf.setIntegerValue",
				context: `when setting the value of the BOOLEAN record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be a boolean"
			};
		}

		// update the value:
		const update = {
			action: "SET",
			value
		};
		return this._updateValue(key, Shelf.Type.BOOLEAN, update);
	}

	/**
	 * Flip the value of a record of type BOOLEAN associated with the given key.
	 *
	 * @name module:data.Shelf#flipBooleanValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @return {Promise&lt;boolean>}				the new, flipped, value
	 * @throws {Object.&lt;string, *>} 		exception if there is no record with the given key, or
	 * 	if there is a record but it is not of type BOOLEAN
	 */
	flipBooleanValue({key} = {})
	{
		// update the value:
		const update = {
			action: "FLIP"
		};
		return this._updateValue(key, Shelf.Type.BOOLEAN, update);
	}

	/**
	 * Get the value of a record of type INTEGER associated with the given key.
	 *
	 * @name module:data.Shelf#getIntegerValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 			key as an array of key components
	 * @param {number} options.defaultValue		the default value returned if no record with the given key
	 * 	exists on the shelf
	 * @return {Promise&lt;number>}							the value associated with the key
	 * @throws {Object.&lt;string, *>} 					exception if there is no record with the given key,
	 * 	or if there is a record but it is locked or it is not of type BOOLEAN
	 */
	getIntegerValue({key, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.INTEGER, {defaultValue});
	}

	/**
	 * Set the value of a record of type INTEGER associated with the given key.
	 *
	 * @name module:data.Shelf#setIntegerValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @param {number} options.value 		the new value
	 * @return {Promise&lt;number>} 				the new value
	 * @throws {Object.&lt;string, *>} 		exception if value is not an integer, or or if there is no record
	 * 	with the given key, or if there is a record but it is locked or it is not of type INTEGER
	 */
	setIntegerValue({key, value} = {})
	{
		// check the value:
		if (!Number.isInteger(value))
		{
			throw {
				origin: "Shelf.setIntegerValue",
				context: `when setting the value of the INTEGER record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be an integer"
			};
		}

		// update the value:
		const update = {
			action: "SET",
			value
		};
		return this._updateValue(key, Shelf.Type.INTEGER, update);
	}

	/**
	 * Add a delta to  the value of a record of type INTEGER associated with the given key.
	 *
	 * @name module:data.Shelf#addIntegerValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 	key as an array of key components
	 * @param {number} options.delta 		the delta, positive or negative, to add to the value
	 * @return {Promise&lt;number>} 					the new value
	 * @throws {Object.&lt;string, *>} 			exception if delta is not an integer, or if there is no record with the given
	 * 	key, or if there is a record but it is locked or it is not of type INTEGER
	 */
	addIntegerValue({key, delta} = {})
	{
		// check the delta:
		if (!Number.isInteger(delta))
		{
			throw {
				origin: "Shelf.setIntegerValue",
				context: `when adding a value to the value of the INTEGER record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be an integer"
			};
		}

		// update the value:
		const update = {
			action: "ADD",
			delta
		};
		return this._updateValue(key, Shelf.Type.INTEGER, update);
	}

	/**
	 * Get the value of a record of type TEXT associated with the given key.
	 *
	 * @name module:data.Shelf#getTextValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key					 	key as an array of key components
	 * @param {string} options.defaultValue		the default value returned if no record with the given key exists on
	 * 	the shelf
	 * @return {Promise&lt;string>}									the value associated with the key
	 * @throws {Object.&lt;string, *>} 						exception if there is a record associated with the given key but it is
	 * 	not of type TEXT
	 */
	getTextValue({key, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.TEXT, {defaultValue});
	}

	/**
	 * Set the value of a record of type TEXT associated with the given key.
	 *
	 * @name module:data.Shelf#setTextValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 	key as an array of key components
	 * @param {string} options.value 			the new value
	 * @return {Promise&lt;string>} 					the new value
	 * @throws {Object.&lt;string, *>} 			exception if value is not a string, or if there is a record associated
	 * 	with the given key but it is not of type TEXT
	 */
	setTextValue({key, value} = {})
	{
		// check the value:
		if (typeof value !== "string")
		{
			throw {
				origin: "Shelf.setTextValue",
				context: `when setting the value of the TEXT record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be a string"
			};
		}

		// update the value:
		const update = {
			action: "SET",
			value
		};
		return this._updateValue(key, Shelf.Type.TEXT, update);
	}

	/**
	 * Get the value of a record of type LIST associated with the given key.
	 *
	 * @name module:data.Shelf#getListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key					 			key as an array of key components
	 * @param {Array.&lt;*>} options.defaultValue		the default value returned if no record with the given key exists on
	 * 	the shelf
	 * @return {Promise&lt;Array.&lt;*>>}								the value associated with the key
	 * @throws {Object.&lt;string, *>} 								exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type LIST
	 */
	getListValue({key, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.LIST, {defaultValue});
	}

	/**
	 * Set the value of a record of type LIST associated with the given key.
	 *
	 * @name module:data.Shelf#setListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 		key as an array of key components
	 * @param {Array.&lt;*>} options.value 	the new value
	 * @return {Promise&lt;Array.&lt;*>>}				the new value
	 * @throws {Object.&lt;string, *>} 				exception if value is not an array or if there is no record with the given key,
	 * 	or if there is a record but it is locked or it is not of type LIST
	 */
	setListValue({key, value} = {})
	{
		// check the value:
		if (!Array.isArray(value))
		{
			throw {
				origin: "Shelf.setListValue",
				context: `when setting the value of the LIST record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be an array"
			};
		}

		// update the value:
		const update = {
			action: "SET",
			value
		};
		return this._updateValue(key, Shelf.Type.LIST, update);
	}

	/**
	 * Append an element, or a list of elements, to the value of a record of type LIST associated with the given key.
	 *
	 * @name module:data.Shelf#appendListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @param {*} options.elements 		the element or list of elements to be appended
	 * @return {Promise&lt;Array.&lt;*>>}		the new value
	 * @throws {Object.&lt;string, *>} 		exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type LIST
	 */
	appendListValue({key, elements} = {})
	{
		// update the value:
		const update = {
			action: "APPEND",
			elements
		};
		return this._updateValue(key, Shelf.Type.LIST, update);
	}

	/**
	 * Pop an element, at the given index, from the value of a record of type LIST associated
	 * with the given key.
	 *
	 * @name module:data.Shelf#popListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key						key as an array of key components
	 * @param {number} [options.index = -1] 	the index of the element to be popped
	 * @return {Promise&lt;*>}											the popped element
	 * @throws {Object.&lt;string, *>} 						exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type LIST
	 */
	popListValue({key, index = -1} = {})
	{
		// update the value:
		const update = {
			action: "POP",
			index
		};
		return this._updateValue(key, Shelf.Type.LIST, update);
	}

	/**
	 * Empty the value of a record of type LIST associated with the given key.
	 *
	 * @name module:data.Shelf#clearListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @return {Promise&lt;Array.&lt;*>>}		the new, empty value, i.e. []
	 * @throws {Object.&lt;string, *>} 		exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type LIST
	 */
	clearListValue({key} = {})
	{
		// update the value:
		const update = {
			action: "CLEAR"
		};
		return this._updateValue(key, Shelf.Type.LIST, update);
	}

	/**
	 * Shuffle the elements of the value of a record of type LIST associated with the given key.
	 *
	 * @name module:data.Shelf#shuffleListValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @return {Promise&lt;Array.&lt;*>>}		the new, shuffled value
	 * @throws {Object.&lt;string, *>} 		exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type LIST
	 */
	shuffleListValue({key} = {})
	{
		// update the value:
		const update = {
			action: "SHUFFLE"
		};
		return this._updateValue(key, Shelf.Type.LIST, update);
	}


	/**
	 * Get the names of the fields in the dictionary record associated with the given key.
	 *
	 * @name module:data.Shelf#getDictionaryFieldNames
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		key as an array of key components
	 * @return {Promise&lt;string[]>}			the list of field names
	 * @throws {Object.&lt;string, *>} 		exception if there is no record with the given key, or if there is a record
	 * 	but it is locked or it is not of type DICTIONARY
	 */
	async getDictionaryFieldNames({key} = {})
	{
		return this._getValue(key, Shelf.Type.DICTIONARY, {fieldNames: true});
	}

	/**
	 * Get the value of a given field in the dictionary record associated with the given key.
	 *
	 * @name module:data.Shelf#getDictionaryFieldValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key					 	key as an array of key components
	 * @param {string} options.fieldName				the name of the field
	 * @param {boolean} options.defaultValue		the default value returned if no record with the given key exists on
	 * 	the shelf, or if is a record of type DICTIONARY with the given key but it has no such field
	 * @return {Promise&lt;*>}											the value of that field
	 * @throws {Object.&lt;string, *>} 						exception if there is no record with the given key,
	 * 	or if there is a record but it is locked or it is not of type DICTIONARY
	 */
	async getDictionaryFieldValue({key, fieldName, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.DICTIONARY, {fieldName, defaultValue});
	}

	/**
	 * Set a field in the dictionary record associated to the given key.
	 *
	 * @name module:data.Shelf#setDictionaryFieldValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key					key as an array of key components
	 * @param {string} options.fieldName			the name of the field
	 * @param {*} options.fieldValue					the value of the field
	 * @return {Promise&lt;Object.&lt;string, *>>}	the updated dictionary
	 * @throws {Object.&lt;string, *>} 					exception if there is no record with the given key,
	 * 	or if there is a record but it is locked or it is not of type DICTIONARY
	 */
	async setDictionaryFieldValue({key, fieldName, fieldValue} = {})
	{
		// update the value:
		const update = {
			action: "FIELD_SET",
			fieldName,
			fieldValue
		};
		return this._updateValue(key, Shelf.Type.DICTIONARY, update);
	}

	/**
	 * Get the value of a record of type DICTIONARY associated with the given key.
	 *
	 * @name module:data.Shelf#getDictionaryValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key		 									key as an array of key components
	 * @param {Object.&lt;string, *>} options.defaultValue		the default value returned if no record with the given key
	 * 	exists on the shelf
	 * @return {Promise&lt;Object.&lt;string, *>>}							the value associated with the key
	 * @throws {Object.&lt;string, *>} 											exception if there is no record with the given key,
	 * 	or if there is a record but it is locked or it is not of type DICTIONARY
	 */
	getDictionaryValue({key, defaultValue} = {})
	{
		return this._getValue(key, Shelf.Type.DICTIONARY, {defaultValue});
	}

	/**
	 * Set the value of a record of type DICTIONARY associated with the given key.
	 *
	 * @name module:data.Shelf#setDictionaryValue
	 * @function
	 * @public
	 * @param {Object} options
	 * @param {string[]} options.key							key as an array of key components
	 * @param {Object.&lt;string, *>} options.value 	the new value
	 * @return {Promise&lt;Object.&lt;string, *>>} 			the new value
	 * @throws {Object.&lt;string, *>} 							exception if value is not an object, or or if there is no record
	 * 	with the given key, or if there is a record but it is locked or it is not of type DICTIONARY
	 */
	setDictionaryValue({key, value} = {})
	{
		// check the value:
		if (typeof value !== "object")
		{
			throw {
				origin: "Shelf.setDictionaryValue",
				context: `when setting the value of the DICTIONARY record associated with the key: ${JSON.stringify(key)}`,
				error: "the value should be an object"
			};
		}

		// update the value:
		const update = {
			action: "SET",
			value
		};
		return this._updateValue(key, Shelf.Type.DICTIONARY, update);
	}

	/**
	 * Schedulable component that will block the experiment until the counter associated with the given key
	 * has been incremented by the given amount.
	 *
	 * @name module:data.Shelf#incrementComponent
	 * @function
	 * @public
	 * @param key
	 * @param increment
	 * @param callback
	 * @returns {function(): module:util.Scheduler.Event|Symbol|*} a component that can be scheduled
	 *
	 * @example
	 * const flowScheduler = new Scheduler(psychoJS);
	 * var experimentCounter = '&lt;>';
	 * flowScheduler.add(psychoJS.shelf.incrementComponent(['counter'], 1, (value) => experimentCounter = value));
	 */
	incrementComponent(key = [], increment = 1, callback)
	{
		const response = {
			origin: 'Shelf.incrementComponent',
			context: 'when making a component to increment a shelf counter'
		};

		try
		{
			// TODO replace this._incrementComponent by a component with a unique name
			let incrementComponent = {};
			incrementComponent.status = PsychoJS.Status.NOT_STARTED;
			return () =>
			{
				if (incrementComponent.status === PsychoJS.Status.NOT_STARTED)
				{
					incrementComponent.status = PsychoJS.Status.STARTED;
					this.increment(key, increment)
						.then( (newValue) =>
						{
							callback(newValue);
							incrementComponent.status = PsychoJS.Status.FINISHED;
						});
				}

				return (incrementComponent.status === PsychoJS.Status.FINISHED) ?
					Scheduler.Event.NEXT :
					Scheduler.Event.FLIP_REPEAT;
			};
		}
		catch (error)
		{
			this._status = Shelf.Status.ERROR;
			throw {...response, error};
		}
	}

	/**
	 * Get the name of a group, using a counterbalanced design.
	 *
	 * @name module:data.Shelf#counterBalanceSelect
	 * @function
	 * @public
	 * @param {string[]} key						key as an array of key components
	 * @param {string[]} groups				the names of the groups
	 * @param {number[]} groupSizes	the size of the groups
	 * @return {Promise&lt;any>}
	 */
	async counterBalanceSelect(key, groups, groupSizes)
	{
		const response = {
			origin: 'Shelf.counterBalanceSelect',
			context: `when getting the name of a group, using a counterbalanced design, with key: ${JSON.stringify(key)}`
		};

		try
		{
			await this._checkAvailability("counterBalanceSelect");
			this._checkKey(key);

			// prepare the request:
			// const componentList = key.reduce((list, component) => list + '+' + component, '');
			const url = `${this._psychoJS.config.pavlovia.URL}/api/v2/shelf/${this._psychoJS.config.session.token}/counterbalance`;
			const data = {
				key,
				groups,
				groupSizes
			};

			// query the server:
			const response = await fetch(url, {
				method: 'PUT',
				mode: 'cors',
				cache: 'no-cache',
				credentials: 'same-origin',
				redirect: 'follow',
				referrerPolicy: 'no-referrer',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(data)
			});

			// convert the response to json:
			const document = await response.json();

			if (response.status !== 200)
			{
				throw ('error' in document) ? document.error : document;
			}

			// return the updated value:
			this._status = Shelf.Status.READY;
			return [ document.group, document.finished ];
		}
		catch (error)
		{
			this._status = Shelf.Status.ERROR;
			throw {...response, error};
		}
	}


	/**
	 * Update the value associated with the given key.
	 *
	 * &lt;p>This is a generic method, typically called from the Shelf helper methods, e.g. setBinaryValue.&lt;/p>
	 *
	 * @name module:data.Shelf#_updateValue
	 * @function
	 * @protected
	 * @param {string[]} key					 	key as an array of key components
	 * @param {Shelf.Type} type 				the type of the record associated with the given key
	 * @param {*} update 							the desired update
	 * @return {Promise&lt;any>}					the updated value
	 * @throws {Object.&lt;string, *>} 	exception if there is no record associated with the given key or if there is one
	 * 	but it is not of the given type
	 */
	async _updateValue(key, type, update)
	{
		const response = {
			origin: 'Shelf._updateValue',
			context: `when updating the value of the ${Symbol.keyFor(type)} record associated with key: ${JSON.stringify(key)}`
		};

		try
		{
			await this._checkAvailability("_updateValue");
			this._checkKey(key);

			// prepare the request:
			const url = `${this._psychoJS.config.pavlovia.URL}/api/v2/shelf/${this._psychoJS.config.session.token}/value`;
			const data = {
				key,
				type: Symbol.keyFor(type),
				update
			};

			// query the server:
			const response = await fetch(url, {
				method: 'POST',
				mode: 'cors',
				cache: 'no-cache',
				credentials: 'same-origin',
				redirect: 'follow',
				referrerPolicy: 'no-referrer',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(data)
			});

			// convert the response to json:
			const document = await response.json();

			if (response.status !== 200)
			{
				throw ('error' in document) ? document.error : document;
			}

			// return the updated value:
			this._status = Shelf.Status.READY;
			return document.value;
		}
		catch (error)
		{
			this._status = Shelf.Status.ERROR;
			throw {...response, error};
		}
	}

	/**
	 * Get the value associated with the given key.
	 *
	 * &lt;p>This is a generic method, typically called from the Shelf helper methods, e.g. getBinaryValue.&lt;/p>
	 *
	 * @name module:data.Shelf#_getValue
	 * @function
	 * @protected
	 * @param {string[]} key					 	key as an array of key components
	 * @param {Shelf.Type} type 				the type of the record associated with the given key
	 * @param {Object} [options] 			the options, e.g. the default value returned if no record with the
	 * given key exists on the shelf
	 * @return {Promise&lt;any>}					the value
	 * @throws {Object.&lt;string, *>} 	exception if there is a record associated with the given key but it is not of
	 * 	the given type
	 */
	async _getValue(key, type, options)
	{
		const response = {
			origin: 'Shelf._getValue',
			context: `when getting the value of the ${Symbol.keyFor(type)} record associated with key: ${JSON.stringify(key)}`
		};

		try
		{
			await this._checkAvailability("_getValue");
			this._checkKey(key);

			// prepare the request:
			const url = `${this._psychoJS.config.pavlovia.URL}/api/v2/shelf/${this._psychoJS.config.session.token}/value`;
			const data = {
				key,
				type: Symbol.keyFor(type)
			};

			if (typeof options !== 'undefined')
			{
				for (const attribute in options)
				{
					if (typeof options[attribute] !== "undefined")
					{
						data[attribute] = options[attribute];
					}
				}
			}

			// query the server:
			const response = await fetch(url, {
				method: 'PUT',
				mode: 'cors',
				cache: 'no-cache',
				credentials: 'same-origin',
				redirect: 'follow',
				referrerPolicy: 'no-referrer',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(data)
			});

			const document = await response.json();

			if (response.status !== 200)
			{
				throw ('error' in document) ? document.error : document;
			}

			// return the value:
			this._status = Shelf.Status.READY;
			return document.value;
		}
		catch (error)
		{
			this._status = Shelf.Status.ERROR;
			throw {...response, error};
		}
	}

	/**
	 * Check whether it is possible to run a given shelf command.
	 *
	 * &lt;p>Since all Shelf methods call _checkAvailability, we also use it as a means to throttle those calls.&lt;/p>
	 *
	 * @name module:data.Shelf#_checkAvailability
	 * @function
	 * @public
	 * @param {string} [methodName=""] 	name of the method requiring a check
	 * @throws {Object.&lt;string, *>} 				exception if it is not possible to run the given shelf command
	 */
	_checkAvailability(methodName = "")
	{
		// Shelf requires access to the server, where the key/value pairs are stored:
		if (this._psychoJS.config.environment !== ExperimentHandler.Environment.SERVER)
		{
			throw {
				origin: 'Shelf._checkAvailability',
				context: 'when checking whether Shelf is available',
				error: 'the experiment has to be run on the server: shelf commands are not available locally'
			};
		}

		// throttle calls to Shelf methods:
		const self = this;
		return new Promise((resolve, reject) =>
		{
			const now = performance.now();

			// if the last scheduled call already occurred, schedule this one as soon as possible,
			// taking into account the throttling period:
			let timeoutDuration;
			if (now > self._lastScheduledCallTimestamp)
			{
				timeoutDuration = Math.max(0.0, self._throttlingPeriod_ms - (now - self._lastCallTimestamp));
				self._lastScheduledCallTimestamp = now + timeoutDuration;
			}
			// otherwise, schedule it after the next call:
			else
			{
				self._lastScheduledCallTimestamp += self._throttlingPeriod_ms;
				timeoutDuration = self._lastScheduledCallTimestamp;
			}

			setTimeout(
				() => {
					self._lastCallTimestamp = performance.now();
					self._status = Shelf.Status.BUSY;
					resolve();
					},
				timeoutDuration
			);
		});
	}

	/**
	 * Check the validity of the key.
	 *
	 * @name module:data.Shelf#_checkKey
	 * @function
	 * @public
	 * @param {object} key 							key whose validity is to be checked
	 * @throws {Object.&lt;string, *>} 	exception if the key is invalid
	 */
	_checkKey(key)
	{
		// the key must be a non empty array:
		if (!Array.isArray(key) || key.length === 0)
		{
			throw 'the key must be a non empty array';
		}

		if (key.length > Shelf.#MAX_KEY_LENGTH)
		{
			throw 'the key consists of too many components';
		}

		// the only @&lt;component> in the key should be @designer and @experiment
		// TODO
	}
}

/**
 * Shelf status
 *
 * @name module:data.Shelf#Status
 * @enum {Symbol}
 * @readonly
 * @public
 */
Shelf.Status = {
	/**
	 * The shelf is ready.
	 */
	READY: Symbol.for('READY'),

	/**
	 * The shelf is busy, e.g. storing or retrieving values.
	 */
	BUSY: Symbol.for('BUSY'),

	/**
	 * The shelf has encountered an error.
	 */
	ERROR: Symbol.for('ERROR')
};

/**
 * Shelf record types.
 *
 * @enum {Symbol}
 * @readonly
 * @public
 */
Shelf.Type = {
	INTEGER: Symbol.for('INTEGER'),
	TEXT: Symbol.for('TEXT'),
	DICTIONARY: Symbol.for('DICTIONARY'),
	BOOLEAN: Symbol.for('BOOLEAN'),
	LIST: Symbol.for('LIST')
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-core.html">core</a></li><li><a href="module-data.html">data</a></li><li><a href="module-sound.html">sound</a></li><li><a href="module-util.html">util</a></li><li><a href="module-visual.html">visual</a></li></ul><h3>Classes</h3><ul><li><a href="FaceDetector_FaceDetector.html">FaceDetector</a></li><li><a href="module.data.MultiStairHandler.html">MultiStairHandler</a></li><li><a href="module.data.QuestHandler.html">QuestHandler</a></li><li><a href="module-core.BuilderKeyResponse.html">BuilderKeyResponse</a></li><li><a href="module-core.EventManager.html">EventManager</a></li><li><a href="module-core.GUI.html">GUI</a></li><li><a href="module-core.Keyboard.html">Keyboard</a></li><li><a href="module-core.KeyPress.html">KeyPress</a></li><li><a href="module-core.Logger.html">Logger</a></li><li><a href="module-core.MinimalStim.html">MinimalStim</a></li><li><a href="module-core.Mouse.html">Mouse</a></li><li><a href="module-core.PsychoJS.html">PsychoJS</a></li><li><a href="module-core.ServerManager.html">ServerManager</a></li><li><a href="module-core.Window.html">Window</a></li><li><a href="module-data.ExperimentHandler.html">ExperimentHandler</a></li><li><a href="module-data.MultiStairHandler.html">MultiStairHandler</a></li><li><a href="module-data.QuestHandler.html">QuestHandler</a></li><li><a href="module-data.Shelf.html">Shelf</a></li><li><a href="module-data.TrialHandler.html">TrialHandler</a></li><li><a href="module-hardware.Camera.html">Camera</a></li><li><a href="module-sound.AudioClip.html">AudioClip</a></li><li><a href="module-sound.AudioClipPlayer.html">AudioClipPlayer</a></li><li><a href="module-sound.Microphone.html">Microphone</a></li><li><a href="module-sound.Sound.html">Sound</a></li><li><a href="module-sound.TonePlayer.html">TonePlayer</a></li><li><a href="module-sound.TrackPlayer.html">TrackPlayer</a></li><li><a href="module-sound.Transcriber.html">Transcriber</a></li><li><a href="module-sound.Transcript.html">Transcript</a></li><li><a href="module-util.Clock.html">Clock</a></li><li><a href="module-util.Color.html">Color</a></li><li><a href="module-util.CountdownTimer.html">CountdownTimer</a></li><li><a href="module-util.EventEmitter.html">EventEmitter</a></li><li><a href="module-util.MixinBuilder.html">MixinBuilder</a></li><li><a href="module-util.MonotonicClock.html">MonotonicClock</a></li><li><a href="module-util.PsychObject.html">PsychObject</a></li><li><a href="module-util.Scheduler.html">Scheduler</a></li><li><a href="module-visual.ButtonStim.html">ButtonStim</a></li><li><a href="module-visual.FaceDetector.html">FaceDetector</a></li><li><a href="module-visual.Form.html">Form</a></li><li><a href="module-visual.GratingStim.html">GratingStim</a></li><li><a href="module-visual.ImageStim.html">ImageStim</a></li><li><a href="module-visual.MovieStim.html">MovieStim</a></li><li><a href="module-visual.Polygon.html">Polygon</a></li><li><a href="module-visual.Rect.html">Rect</a></li><li><a href="module-visual.ShapeStim.html">ShapeStim</a></li><li><a href="module-visual.Slider.html">Slider</a></li><li><a href="module-visual.TextBox.html">TextBox</a></li><li><a href="module-visual.TextStim.html">TextStim</a></li><li><a href="module-visual.VisualStim.html">VisualStim</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-sound.SoundPlayer.html">SoundPlayer</a></li></ul><h3>Mixins</h3><ul><li><a href="module-core.WindowMixin.html">WindowMixin</a></li><li><a href="module-util.ColorMixin.html">ColorMixin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#pad">pad</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Jun 16 2022 12:47:14 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
